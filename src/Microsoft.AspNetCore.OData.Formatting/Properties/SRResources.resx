<?xml version="1.0" encoding="utf-8"?>
<root>
    <!-- 
        Microsoft ResX Schema

        Version 1.3

        The primary goals of this format is to allow a simple XML format 
        that is mostly human readable. The generation and parsing of the 
        various data types are done through the TypeConverter classes 
        associated with the data types.

        Example:
    
        ... ado.net/XML headers & schema ...
        <resheader name="resmimetype">text/microsoft-resx</resheader>
        <resheader name="version">1.3</resheader>
        <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
        <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
        <data name="Name1">this is my long string</data>
        <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
        <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
            [base64 mime encoded serialized .NET Framework object]
        </data>
        <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
            [base64 mime encoded string representing a byte array form of the .NET Framework object]
        </data>

        There are any number of "resheader" rows that contain simple 
        name/value pairs.

        Each data row contains a name, and value. The row also contains a 
        type or mimetype. Type corresponds to a .NET class that support 
        text/value conversion through the TypeConverter architecture. 
        Classes that don't support this are serialized and stored with the 
        mimetype set.

        The mimetype is used for serialized objects, and tells the 
        ResXResourceReader how to depersist the object. This is currently not 
        extensible. For a given mimetype the value must be set accordingly:

        Note - application/x-microsoft.net.object.binary.base64 is the format 
        that the ResXResourceWriter will generate, however the reader can 
        read any of the formats listed below.

        mimetype: application/x-microsoft.net.object.binary.base64
        value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

        mimetype: application/x-microsoft.net.object.soap.base64
        value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

        mimetype: application/x-microsoft.net.object.bytearray.base64
        value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
    
    <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
        <xsd:element name="root" msdata:IsDataSet="true">
            <xsd:complexType>
                <xsd:choice maxOccurs="unbounded">
                    <xsd:element name="data">
                        <xsd:complexType>
                            <xsd:sequence>
                                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
                            </xsd:sequence>
                            <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
                            <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
                            <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
                        </xsd:complexType>
                    </xsd:element>
                    <xsd:element name="resheader">
                        <xsd:complexType>
                            <xsd:sequence>
                                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                            </xsd:sequence>
                            <xsd:attribute name="name" type="xsd:string" use="required" />
                        </xsd:complexType>
                    </xsd:element>
                </xsd:choice>
            </xsd:complexType>
        </xsd:element>
    </xsd:schema>
    <resheader name="resmimetype">
        <value>text/microsoft-resx</value>
    </resheader>
    <resheader name="version">
        <value>1.3</value>
    </resheader>
    <resheader name="reader">
        <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.3500.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
    </resheader>
    <resheader name="writer">
        <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.3500.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
    </resheader>
  <data name="NullContainer" xml:space="preserve">
    <value>The container built by the container builder must not be null.</value>
  </data>
  <data name="DeltaEntityTypeNotAssignable" xml:space="preserve">
    <value>The actual entity type '{0}' is not assignable to the expected type '{1}'.</value>
  </data>
  <data name="CannotSetDynamicPropertyDictionary" xml:space="preserve">
    <value>The dynamic dictionary property '{0}' of type '{1}' cannot be set. The dynamic property dictionary must have a setter.</value>
  </data>
  <data name="UnsupportedEdmTypeKind" xml:space="preserve">
    <value>Found unsupported EdmTypeKind '{0}' in list of available types.</value>
  </data>
  <data name="UnsupportedEdmType" xml:space="preserve">
    <value>The EDM type '{0}' of kind '{1}' is not supported.</value>
  </data>
  <data name="DeltaTypeMismatch" xml:space="preserve">
    <value>Cannot use Delta of type '{0}' on an entity of type '{1}'.</value>
  </data>
  <data name="DeltaNestedResourceNameNotFound" xml:space="preserve">
    <value>Cannot find nested resource name '{0}' in parent resource type '{1}'</value>
  </data>
  <data name="UnexpectedElementType" xml:space="preserve">
    <value>The element type '{0}' of the given collection type '{1}' is not of the type '{2}'.</value>
  </data>
  <data name="CannotWriteType" xml:space="preserve">
    <value>{0} cannot write an object of type '{1}'.</value>
  </data>
  <data name="WriteObjectInlineNotSupported" xml:space="preserve">
    <value>{0} does not support WriteObjectInline.</value>
  </data>
  <data name="CreateODataValueNotSupported" xml:space="preserve">
    <value>{0} does not support CreateODataValue.</value>
  </data>
  <data name="TypeCannotBeSerialized" xml:space="preserve">
    <value>'{0}' cannot be serialized using the ODataMediaTypeFormatter.</value>
  </data>
  <data name="NullElementInCollection" xml:space="preserve">
    <value>Collections cannot contain null elements.</value>
  </data>
  <data name="ArgumentMustBeOfType" xml:space="preserve">
    <value>The argument must be of type '{0}'.</value>
  </data>
  <data name="WriteObjectNotSupported" xml:space="preserve">
    <value>{0} does not support WriteObject.</value>
  </data>
  <data name="WriteToStreamAsyncMustHaveRequest" xml:space="preserve">
    <value>The OData formatter does not support writing client requests. This formatter instance must have an associated request.</value>
  </data>
  <data name="ReadFromStreamAsyncMustHaveRequest" xml:space="preserve">
    <value>The OData formatter requires an attached request in order to deserialize. Controller classes must derive from ODataController or be marked with ODataFormattingAttribute. Custom parameter bindings must call GetPerRequestFormatterInstance on each formatter and use these per-request instances.</value>
  </data>
  <data name="DeserializerDoesNotSupportRead" xml:space="preserve">
    <value>'{0}' does not support Read.</value>
  </data>
  <data name="DoesNotSupportReadInLine" xml:space="preserve">
    <value>Type '{0}' does not support ReadInline.</value>
  </data>
  <data name="TypeCannotBeDeserialized" xml:space="preserve">
    <value>'{0}' cannot be deserialized using the ODataMediaTypeFormatter.</value>
  </data>
  <data name="CollectionShouldHaveAddMethod" xml:space="preserve">
    <value>The type '{0}' of the property '{1}' on type '{2}' does not have an Add method. Consider using a collection type that does have an Add method - for example IList&lt;T&gt; or ICollection&lt;T&gt;.</value>
  </data>
  <data name="GetOnlyCollectionCannotBeArray" xml:space="preserve">
    <value>The value of the property '{0}' on type '{1}' is an array. Consider adding a setter for the property.</value>
  </data>
  <data name="CollectionParameterShouldHaveAddMethod" xml:space="preserve">
    <value>The type '{0}' of the parameter '{1}' does not have an Add method. Consider using a collection type that does have an Add method - for example IList&lt;T&gt; or ICollection&lt;T&gt;.</value>
  </data>
  <data name="CollectionShouldHaveClearMethod" xml:space="preserve">
    <value>The type '{0}' of the property '{1}' on type '{2}' does not have a Clear method. Consider using a collection type that does have a Clear method, such as IList&lt;T&gt; or ICollection&lt;T&gt;.</value>
  </data>
  <data name="NestedCollectionsNotSupported" xml:space="preserve">
    <value>The type '{0}' is a nested collection type. Nested collection types are not allowed.</value>
  </data>
  <data name="PropertyMustBeStringLengthOne" xml:space="preserve">
    <value>The value must be a string with a length of 1.</value>
  </data>
  <data name="PropertyMustBeStringMaxLengthOne" xml:space="preserve">
    <value>The value must be a string with a maximum length of 1.</value>
  </data>
  <data name="PropertyMustBeString" xml:space="preserve">
    <value>The value must be a string.</value>
  </data>
  <data name="CannotAddToNullCollection" xml:space="preserve">
    <value>The property '{0}' on type '{1}' returned a null value. The input stream contains collection items which cannot be added if the instance is null.</value>
  </data>
  <data name="DuplicateDynamicPropertyNameFound" xml:space="preserve">
    <value>Duplicate dynamic property name '{0}' found in open type '{1}'. Each dynamic property name must be unique.</value>
  </data>
  <data name="InvalidODataUntypedValue" xml:space="preserve">
    <value>The given untyped value '{0}' in payload is invalid. Consider using a OData type annotation explicitly.</value>
  </data>
  <data name="PropertyIsNotCollection" xml:space="preserve">
    <value>The type '{0}' of the property '{1}' on type '{2}' must be a collection.</value>
  </data>
  <data name="PropertyMustBeDateTimeOffsetOrDate" xml:space="preserve">
    <value>The value must be a DateTimeOffset or Date.</value>
  </data>
  <data name="PropertyMustBeTimeOfDay" xml:space="preserve">
    <value>The value must be a Edm.TimeOfDay.</value>
  </data>
  <data name="PropertyMustBeBoolean" xml:space="preserve">
    <value>The value must be a boolean.</value>
  </data>
  <data name="CannotDeserializeUnknownProperty" xml:space="preserve">
    <value>The property '{0}' does not exist on type '{1}'. Make sure to only use property names that are defined by the type.</value>
  </data>
  <data name="ODataPathMissing" xml:space="preserve">
    <value>The operation cannot be completed because no ODataPath is available for the request.</value>
  </data>
  <data name="EdmTypeNotSupported" xml:space="preserve">
    <value>{0} is not a supported EDM type.</value>
  </data>
  <data name="MultipleMatchingClrTypesForEdmType" xml:space="preserve">
    <value>More than one matching CLR type found for the EDM type {0}.\nThe matching CLR types are {1}.</value>
  </data>
  <data name="MappingDoesNotContainResourceType" xml:space="preserve">
    <value>The provided mapping does not contain a resource for the resource type '{0}'.</value>
  </data>
  <data name="ModelMissingFromReadContext" xml:space="preserve">
    <value>The EDM model is missing on the read context. The model is required on the read context to deserialize the payload.</value>
  </data>
  <data name="CannotPatchNavigationProperties" xml:space="preserve">
    <value>Cannot apply PATCH to navigation property '{0}' on entity type '{1}'.</value>
  </data>
  <data name="NestedPropertyNotfound" xml:space="preserve">
    <value>Cannot find nested property '{0}' on the resource type '{1}'.</value>
  </data>
  <data name="ResourceTypeNotInModel" xml:space="preserve">
    <value>Cannot find the resource type '{0}' in the model.</value>
  </data>
  <data name="CannotInstantiateAbstractResourceType" xml:space="preserve">
    <value>An instance of the abstract resource type '{0}' was found. Abstract resource types cannot be instantiated.</value>
  </data>
  <data name="NavigationSourceMissingDuringDeserialization" xml:space="preserve">
    <value>The related entity set or singleton cannot be found from the OData path. The related entity set or singleton is required to deserialize the payload.</value>
  </data>
  <data name="DynamicResourceSetTypeNameIsRequired" xml:space="preserve">
    <value>The type name of the dynamic resource set '{0}' is required and cannot be empty. Consider using a OData type annotation explicitly.</value>
  </data>
  <data name="TypeMustBeResourceSet" xml:space="preserve">
    <value>{0} is not a resource set type. Only resource set are supported.</value>
  </data>
  <data name="RequestNotActionInvocation" xml:space="preserve">
    <value>The last segment of the request URI '{0}' was not recognized as an OData action.</value>
  </data>
  <data name="PropertyMustBeEnum" xml:space="preserve">
    <value>The value with type '{0}' must have type '{1}'.</value>
  </data>
  <data name="TypeMustBeEnumOrNullableEnum" xml:space="preserve">
    <value>The type '{0}' must be an enum or Nullable&lt;T&gt; where T is an enum type.</value>
  </data>
  <data name="EdmTypeCannotBeNull" xml:space="preserve">
    <value>The EDM type of the object of type '{0}' is null. The EDM type of an {1} cannot be null.</value>
  </data>
  <data name="RequestMustHaveModel" xml:space="preserve">
    <value>The request must have an associated EDM model.</value>
  </data>
  <data name="UnableToDetermineMetadataUrl" xml:space="preserve">
    <value>The ODataMediaTypeFormatter must be able to determine the metadata URL for a request in order to serialize the response.</value>
  </data>
  <data name="CannotSerializerNull" xml:space="preserve">
    <value>Cannot serialize a null '{0}'.</value>
  </data>
  <data name="EdmComplexObjectNullRef" xml:space="preserve">
    <value>Cannot get property '{0}' of a null EDM object of type '{1}'.</value>
  </data>
  <data name="SelectionTypeNotSupported" xml:space="preserve">
    <value>$select does not support selections of type '{0}'.</value>
  </data>
  <data name="PropertyNotFound" xml:space="preserve">
    <value>The EDM instance of type '{0}' is missing the property '{1}'.</value>
  </data>
  <data name="EdmObjectNull" xml:space="preserve">
    <value>The property 'EdmObject' of {0} cannot be null.</value>
  </data>
  <data name="DynamicPropertyNameAlreadyUsedAsDeclaredPropertyName" xml:space="preserve">
    <value>The name of dynamic property '{0}' was already used as the declared property name of open type '{1}'.</value>
  </data>
  <data name="TypeOfDynamicPropertyNotSupported" xml:space="preserve">
    <value>The type '{0}' of dynamic property '{1}' is not supported.</value>
  </data>
  <data name="DynamicPropertyCannotBeSerialized" xml:space="preserve">
    <value>The dynamic property '{0}' with Edm type '{1}' cannot be serialized.</value>
  </data>
  <data name="KeyValueCannotBeNull" xml:space="preserve">
    <value>Key property '{0}' of type '{1}' is null. Key properties cannot have null values.</value>
  </data>
  <data name="ClrTypeNotInModel" xml:space="preserve">
    <value>The given model does not contain the type '{0}'.</value>
  </data>
  <data name="RootElementNameMissing" xml:space="preserve">
    <value>The 'RootElementName' property is required on '{0}'.</value>
  </data>
  <data name="FormatterReadIsNotSupportedForType" xml:space="preserve">
    <value>Reading type '{0}' is not supported by '{1}'.</value>
  </data>
  <data name="ModelBinderUtil_ModelMetadataCannotBeNull" xml:space="preserve">
    <value>The binding context cannot have a null ModelMetadata.</value>
  </data>
</root>